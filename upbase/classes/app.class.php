<?php
/** 
 * ?
 * @file app.class.php
 * @author Ziba Scott <ziba@linuxbox.com>
 *
 * @package Upbase
 */



function dump($string){
	echo "<pre>\n";
	print_r($string);
	echo "\n</pre>\n";
}


require_once("upbase/classes/library_wrappers/app.smarty.class.php");

/**
 * An array of paths that apache requires access to.
 * @global array $GLOBALS['upbase_web_writable_dirs']
 * @name $upbase_web_writable_dirs
 */
$GLOBALS['upbase_web_writable_dirs'] = array();

/**
 * Application description and state.
 * This class keeps track of application-wide state.
 */
class UpbaseApp {
	var $smarty;
	var $sys_errors = array();

	/**
	 * Debugging messages to be displayed in the debug panel.
	 * This info is generated by UpbaseApp::dbug.
	 * @var $debugging
	 */
	var $debugging=array();

	/**
	 * Timing information to be displayed in debug panel.
	 * This information is generated by UpbaseApp::start_time and 
	 * UpbaseApp::end_time.
	 * UpbaseApp::start_time lets you give names to the tasks you're
	 * timing.
	 * @var array Timing information to be displayed in debug panel.
	 */
	var $timing=array();

	var $start_time;
	var $shell_writable_dirs = array();
	var $shell_executable_files = array();
	var $tail_log = FALSE;
	var $last_time_name = array();
	var $session_log = FALSE;
	var $ajax = FALSE;

	/**
	 * Application constructor.
	 * @global array Not actually used anywhere.  Just stored from here.
	 */
	function UpbaseApp() {
		global $upbase_web_writable_dirs;
		$this->smarty = new AppSmarty();
		$this->dbug('Smarty template compile directory',$this->smarty->compile_dir);
		$upbase_web_writable_dirs[] = $this->smarty->compile_dir;
		$this->start_time = $this->microtime_float();
		$this->timing['Application']['start'] = 0;
		array_push($this->last_time_name, 'Application');
	}

	function jpgraph_init(){
		$this->start_time("Initializing jpgraph include paths");
		require_once('upbase/classes/library_wrappers/app.jpgraph.class.php');
		$this->end_time();
	}

	//function adodb_init($dbtype, $server, $user, $password, $database){
	function adodb_init($dsn){
		$this->start_time("Initializing ADOdb database connection");
    require('upbase/libs/adodb/adodb.inc.php');  # load code common to ADOdb
    $this->adodb = &ADONewConnection($dsn);  # create a mysql connection
    //$this->adodb->debug=TRUE;
    //    $this->adodb->PConnect($server, $userid, $password, $database);
		$this->end_time();
    return $this->adodb;
	}

	function peardb_init($dsn, $options = FALSE){
		global $upbase_debugging;
		$this->start_time("Initializing PEAR DB database connection");
  	ini_set('include_path',ini_get('include_path').':upbase/libs/');
		require_once('upbase/libs/DB.php');

		
		if(!$options){
			$options['debug']=2;
		}

		// Initialize the PEAR connection
		$this->peardb = DB::connect($dsn, $options);

		if (DB::isError($this->peardb)){
			trigger_error('The database session has failed to initialize',E_USER_WARNING);
			if($upbase_debugging){
					  trigger_error($this->peardb->getUserInfo(),E_USER_WARNING);
					  trigger_error($this->peardb->getMessage(),E_USER_WARNING);
			}
			else{
					  trigger_error('The database connection error message has been routed to '.$upbase_log_file_directory.'/peardb.log' ,E_USER_NOTICE);
					  $this->log('peardb.log',$this->peardb->getUserInfo());
					  $this->log('peardb.log',$this->peardb->getMessage());
			
			}
		   	$this->end_time();
		    return FALSE;
		}
		$this->end_time();
		return $this->peardb;
	}

	function mcpeardb_init($dsn, $options = FALSE){
		$this->start_time("Initializing McPEAR DB database connection");
		if($this->peardb_init($dsn, $options)){
			require_once('upbase/classes/library_wrappers/app.mcpeardb.class.php');
			$this->mcpeardb = new mcpeardb($this->peardb);
		}
		else{
			trigger_error('Could not initialize mcpeardb: peardb failed to initialize first');
			$this->end_time();
			return FALSE;
		}
		$this->end_time();
		return $this->mcpeardb;
	}

  	function phpmailer_init(){
        global $upbase_general_email_override;
		$this->start_time("Initializing PHPmailer object");
		require_once('upbase/classes/library_wrappers/app.phpmailer.class.php');
        if(!isset($this->phpmailer) || !is_object($this->phpmailer)){
            $this->phpmailer = new AppPHPMailer();
            if(isset($upbase_general_email_override) && !empty($upbase_general_email_override)){
                trigger_error('General email override in effect.  All emails go to: '.$upbase_general_email_override,E_USER_NOTICE);
            }
        }
		$this->end_time();
        return $this->phpmailer;
    }

	function Spreadsheet_Excel_Writer_init(){
		require_once('upbase/libs/Spreadsheet/Excel/Writer.php');
		$this->workbook = new Spreadsheet_Excel_Writer();
		return $this->workbook;
	}

	function html2fpdf_init(){
		require('upbase/libs/html2fpdf302/html2fpdf.php');
		$this->html2fpdf=new HTML2FPDF();
		return $this->html2fpdf;
	}
	

	/**
	 * Write a debugging message into the debugging log.
	 * @param string $name
	 * @param string $value
	 */
	function dbug($name, $value){
		if(is_array($value)){
			$new_value = "Array(".count($value)."):<br/>";
			foreach($value as $k=>$v){
				$new_value .= "$k: $v<br/>";
			}
			$value = $new_value;
		}
		$this->debugging[$name]=$value;
	} // function dbug

	/**
	 * Start a new timing section in the debug logs.
	 * When the debug logs are shown, it can tell you how long it took to
	 * do various tasks.  Use this and end_time() to say what those
	 * sections are.
	 *
	 * Example:
	 * <code>
	 * $this->start_time("Drinking 21 shots");
	 * $this->drink_shots(21);
	 * $this->end-time();
	 * </code>
	 *
	 * @param string $name Name of the timing section - shows in logs.
	 */
	function start_time($name){
		$this->timing[$name]['parent'] = $this->last_time_name[count($this->last_time_name)-1];
		array_push($this->last_time_name, $name);
		$this->timing[$name]['start'] = $this->microtime_float() - $this->start_time;
		if(isset($this->timing[$name]['count'])){
			$this->timing[$name]['count']++;
		}
		else{
			$this->timing[$name]['count'] = 1;
		}
	} // function start_time

	/**
	 * End a timing section that was started by start_time().
	 * If you started a timing section, end it with end_time.  This will
	 * put the timing information into the debugging log.
	 *
	 * @param string $name This is deprecated.  Call with no args.
	 */
	function end_time($name=FALSE){
		if($name){
			trigger_error('Specifying a string in an end time call is deprecated: '.$name);
		}
		$name = $this->last_time_name[count($this->last_time_name)-1];
		$this->timing[$name]['end'] = $this->microtime_float() - $this->start_time;
		if(isset($this->timing[$name]['duration'])){
		 $this->timing[$name]['duration'] = $this->timing[$name]['end'] - $this->timing[$name]['start'] + $this->timing[$name]['duration'];
		 $this->timing[$name]['start'] = 'multiple runs';
		 $this->timing[$name]['end'] = 'multiple runs';
		}
		else{
		 $this->timing[$name]['duration'] = $this->timing[$name]['end'] - $this->timing[$name]['start'];
		}
		if($name == $this->last_time_name[count($this->last_time_name)-1]){
			array_pop($this->last_time_name);
		}
		$this->timing[$name]['depth'] = $this->last_time_name;
	} // function end_time


	/**
	 * Display the app data, using the specified template.
	 *
	 * @global boolean Whether or not we're running in debugging mode.
	 * @global array Directories to search for templates.
	 *
	 * @param string $template Name of the template to use.
	 */
	function display($template){
		global $upbase_debugging, $upbase_templates_dirs;
		$status = TRUE;
		
    if($upbase_debugging){
      // Make the debugging data available but not shown via the default template
      $this->smarty->debugging = TRUE;
      $this->smarty->debug_tpl = "upbase/default_templates/nonsense";
    }
		clearstatcache();
		$this->end_time();
		if(is_writable($this->smarty->compile_dir)){
			$this->smarty->assign('sys_errors',$this->sys_errors);
			$this->dbug('Errors',count($this->sys_errors));
			$this->smarty->assign('upbase_debugging',$upbase_debugging);
			$this->smarty->assign('upbase_debugging_data',$this->debugging);
			$this->smarty->assign('upbase_timing',$this->timing);
			foreach($upbase_templates_dirs as $dir){
				if (file_exists($dir.'/'.$template) ){
					$this->smarty->display($dir.'/'.$template);
					die();
				}
			}
			trigger_error('The template was not found: '.$template);
		}
		else{
		  global $upbase_debugging;
      if($upbase_debugging){
			  $this->check_required_permissions();
      }
      else{
        trigger_error('Please turn on debugging in the upbase configuration file for more information',E_USER_ERROR);
      }
			$status = FALSE;
		}
		return $status;
	} // function display

	/**
	 * ?
	 * @global boolean
	 * @global array
	 *
	 * @param string $template Name of the template to use.
	 */
	function fetch($template){
		global $upbase_debugging, $upbase_templates_dirs;
		
		$status = TRUE;
		clearstatcache();
		if(is_writable($this->smarty->compile_dir)){
			$this->smarty->assign('sys_errors',$this->sys_errors);
			$this->dbug('Errors',count($this->sys_errors));
			$this->smarty->assign('upbase_debugging',$upbase_debugging);
			$this->smarty->assign('upbase_debugging_data',$this->debugging);
			$this->smarty->assign('upbase_timing',$this->timing);
			foreach($upbase_templates_dirs as $dir){
				if (file_exists($dir.'/'.$template) ){
					return $this->smarty->fetch($dir.'/'.$template);
				}
			}
			trigger_error('The template was not found: '.$template);
		}
		else{
			$this->check_required_permissions();
			$status = FALSE;
		}
		return $status;
	} // function fetch

	/**
	 * ?
	 * @param array $data ?
	 * @return array $headers ?
	 */
	function auto_table_headers($data){	
		$headers = array();
		foreach($data[0] as $k=>$v){
			$headers[] = array('name'=>$k,'dbname'=>$k);
		}
		return $headers;
	} // function auto_table_headers

	/**
	 * Useful if database sorting is not an option	
	 * From a posting on php.net by: mail at theopensource dot com
	 * {@link http://us2.php.net/manual/en/function.array-multisort.php}
	 * @param array $array The array you want to sort.
	 * @param array $by The associative array name that is one level deep.
	 * @param string $order ASC or DESC
	 * @param $type num or str
	 * @return array
	 */
	function sort_table_array($array, $by, $order, $type){
		////example: name
			  
		$sortby = "sort$by"; //This sets up what you are sorting by

		$firstval = current($array); //Pulls over the first array

		$vals = array_keys($firstval); //Grabs the associate Arrays

		foreach ($vals as $init){
		   $keyname = "sort$init";
		   $$keyname = array();
		}
		//This was strange because I had problems adding
		//Multiple arrays into a variable variable
		//I got it to work by initializing the variable variables as arrays
		//Before I went any further

		foreach ($array as $key => $row) {
		  
		foreach ($vals as $names){
		   $keyname = "sort$names";
		   $test = array();
		   $test[$key] = $row[$names];
		   $$keyname = array_merge($$keyname,$test);
		  
		}

		}

		//This will create dynamic mini arrays so that I can perform
		//the array multisort with no problem
		//Notice the temp array... I had to do that because I
		//cannot assign additional array elements to a
		//varaiable variable           

		if ($order == "DESC"){   
		if ($type == "num"){
		array_multisort($$sortby,SORT_DESC, SORT_NUMERIC,$array);
		} else {
		array_multisort($$sortby,SORT_DESC, SORT_STRING,$array);
		}
		} else {
		if ($type == "num"){
		array_multisort($$sortby,SORT_ASC, SORT_NUMERIC,$array);
		} else {
		array_multisort($$sortby,SORT_ASC, SORT_STRING,$array);
		}
		}

		//This just goed through and asks the additional arguments
		//What they are doing and are doing variations of
		//the multisort

		return $array;
	} // function sort_table_array


	function microtime_float()
	{
	   list($usec, $sec) = explode(" ", microtime());
	   return ((float)$usec + (float)$sec);
	} 

	function get_owner($file){
			$fileowneruid=fileowner($file);
			$fileownerarray=posix_getpwuid($fileowneruid);
			$fileowner=$fileownerarray['name'];
			return $fileowner;

	}

	function get_group($file){
			$filegroupuid=filegroup($file);
			$filegrouparray=posix_getpwuid($filegroupuid);
			$filegroup=$filegrouparray['name'];
			return $filegroup;	
	}

	function get_apache_user(){
		return $this->get_apache_info('user');
	}

	function get_apache_group(){
		return $this->get_apache_info('group');
	}

	function user_for_uid($id) { 
		$rslt = posix_getpwuid($id);
		return($rslt['name']);
	}

	function group_for_gid($id) { 
		$rslt = posix_getgrgid($id);
		return($rslt['name']);
	}

	/**
	 * Get useful information from apache.
	 * @param string $info Type of info to get: 'user' or 'group'.
	 * @return string
	 */
	function get_apache_info($info){

		$user  = NULL;
		$group = NULL;

		do {
			$out = array();
			$cmd = 'ps -eo user,group,ucomm | grep httpd | grep -v root | uniq';
			exec($cmd, $out);

			if(count($out) < 1) break;
			
			$matches = array();
			preg_match('/(\S+)\s+(\S+)\s+(\S+)/', $out[0], $matches);

			if(count($matches) < 3) break;

			$user  = (is_numeric($matches[1]) === true ? $this->user_for_uid($matches[1]) : $matches[1]);
			$group = (is_numeric($matches[2]) === true ? $this->group_for_gid($matches[2]) : $matches[2]);
		} while(0);

		if($info == 'user'){
			return $user;
		}
		if($info == 'group'){
			return $group;
		}
	} // function get_apache_info


	
	/**
	 * Check if we have appropriate directory permissions.
	 * The upbase app requires that certain directories be writable by the
	 * apache user.  This function checks whether this is the case, before
	 * bothering to do anything else.  It quits if it doesn't get what it
	 * wants.
	 * @global array The paths that we require write permission to.
	 */
	function check_required_permissions(){
		global $upbase_web_writable_dirs;
		foreach($upbase_web_writable_dirs as $dir){
			if(!is_dir($dir)){
				$msg = "The following directory must be writable by the web server: ".getcwd().'/'.$dir."<br/>";
				$msg .= "The directory does not currently exist";
				trigger_error($msg,E_USER_WARNING);
			}
			elseif(!is_writable($dir)){
				$msg = "The following directory must be writable by the web server: ".getcwd().'/'.$dir."<br/>";
				$msg .= "Current file permissions: ".substr(sprintf('%o',fileperms($dir)),-4);
				$msg .= "  (".$this->file_permissions($dir).")";
				trigger_error($msg,E_USER_WARNING);
			}
		}

	} // function check_required_permissions

	/**
	 * Return human-readable file permissions, as in ls.
	 * From php.net.  We get a drwxr-xr-x style string.
	 * @param string $file Path of the file to check.
	 * @return string
	 */
	function file_permissions($file){
		$perms = fileperms($file);

		if (($perms & 0xC000) == 0xC000) {
		   // Socket
		   $info = 's';
		} elseif (($perms & 0xA000) == 0xA000) {
		   // Symbolic Link
		   $info = 'l';
		} elseif (($perms & 0x8000) == 0x8000) {
		   // Regular
		   $info = '-';
		} elseif (($perms & 0x6000) == 0x6000) {
		   // Block special
		   $info = 'b';
		} elseif (($perms & 0x4000) == 0x4000) {
		   // Directory
		   $info = 'd';
		} elseif (($perms & 0x2000) == 0x2000) {
		   // Character special
		   $info = 'c';
		} elseif (($perms & 0x1000) == 0x1000) {
		   // FIFO pipe
		   $info = 'p';
		} else {
		   // Unknown
		   $info = 'u';
		}

		// Owner
		$info .= (($perms & 0x0100) ? 'r' : '-');
		$info .= (($perms & 0x0080) ? 'w' : '-');
		$info .= (($perms & 0x0040) ?
				   (($perms & 0x0800) ? 's' : 'x' ) :
				   (($perms & 0x0800) ? 'S' : '-'));

		// Group
		$info .= (($perms & 0x0020) ? 'r' : '-');
		$info .= (($perms & 0x0010) ? 'w' : '-');
		$info .= (($perms & 0x0008) ?
				   (($perms & 0x0400) ? 's' : 'x' ) :
				   (($perms & 0x0400) ? 'S' : '-'));

		// World
		$info .= (($perms & 0x0004) ? 'r' : '-');
		$info .= (($perms & 0x0002) ? 'w' : '-');
		$info .= (($perms & 0x0001) ?
				   (($perms & 0x0200) ? 't' : 'x' ) :
				   (($perms & 0x0200) ? 'T' : '-'));

		return $info;
	} // function file_permissions

	/**
	 * Compute the intersection of arrays using keys for comparison
	 *
	 * Similar to the array_intersect_key() built-in, currently available in
	 * PHP-CVS only.  Unlike that function, we want $array1's keys to remain
	 * unchanged, but set its values wherever $array2 has a matching key.
	 *
	 * The $array1 parameter is returned by reference, and will contain all 
	 * the values of $array2 which have matching keys that are present
	 * $array1.
	 *
	 * @param array $array1 An array to intersect.  Returned by reference.
	 * @param array $array2 The other array to intersect.
	 * @return bool TRUE if both parameters are arrays and no errors occur, 
	 * else FALSE.  The $array1 parameter is returned by reference.
	 */
	function array_intersect_key2(&$array1, $array2) {
		$rv = FALSE;
		if(is_array($array1) && is_array($array2)) {
			foreach($array1 as $key => $val) {
				if(isset($array2[$key])) {
					$array1[$key] = $array2[$key];
				}
			}	
			$rv = TRUE;
		} // else { $rv = FALSE }

		return($rv);
	} // function array_intersect_key2
	
	
	/**
	 * Compute the difference of arrays using keys for comparison
	 *
	 * Similar to the array_diff_key() built-in, currently available in
	 * PHP-5 only.  
	 * 
	 * @param array $array1 
	 * @param array $array2
	 * @return array an array containing all the values of array1  
	 * that have keys that are not present in array2
	 */
	function array_diff_key2($array1, $array2) {
		$rv = array();

		if(is_array($array1) && is_array($array2)) {
			foreach($array1 as $key => $val) {
				if(!array_key_exists($key, $array2)) {
					$rv[$key] = $array1[$key];
				}
			}	
		} 

		return($rv);
	} // function array_diff_key2


	/**
	 * Log the message to the file.
	 * Dies if it can't write to the log.
	 * @param string $file 
	 * @param string $message
	 * @global string
	 */
	function log($file, $message){
		global $upbase_log_file_directory;
		
		if($this->tail_log){
			echo date('m/d/Y h:i:s').":  $message\n";
		}
		$this->session_log .= date('m/d/Y h:i:s').":  $message\n";

		if(!file_exists($upbase_log_file_directory.'/'.$file)){
			shell_exec("touch $upbase_log_file_directory/".$file);
		}
		
		if (is_writable($upbase_log_file_directory.'/'.$file)) {	
			if (!$handle = fopen($upbase_log_file_directory.'/'.$file, 'a')) {
					 trigger_error("Cannot open file ($upbase_log_file_directory/$file)",E_USER_ERROR);
			}
			else{
				fwrite($handle, "\n".date('m/d/Y h:i:s').":  ");
				fwrite($handle, $message);
				fclose($handle);
			}
		}
		else{
			trigger_error("The log file: $upbase_log_file_directory/".$file." must be writable",E_USER_ERROR);
		}
	} // function log

	// Sanitizing methods
	/**
	 * Check string for sql injection attacks.  Every value that originates
	 * in GET and is put into a sql statement must be passed through this
	 * function for security.
	 * @param string $string A string to be sanitized.
	 * @return string
	 */
	function clean_sql($string){
		$clean = str_replace(";"," ",addslashes(stripslashes($string)));
		return $clean;
	} // function clean_sql
	
	/**
	 * Cleans an array.
	 * This function validates and cleans the values passed in an array.
	 * It ensures that malicious actions cannot be performed.
	 * @param array $array Dirty values.
	 * @return array Clean values.
	 */
	function clean_array($array){
		$clean=array();

		// General search action
		foreach($array as $k=>$v){
			if(is_array($v)){
				$clean[$k] = $this->clean_array($v);
			} else {
				$clean[$k]=$this->clean_sql($v);
			}
		}

		return $clean;
	} // function clean_array

	/**
	 * Same as clean_sql, but for oracle.
	 * @see clean_sql
	 * @param array $array Dirty values.
	 * @return array Clean values.
	 */
	function oracle_clean_array($array){
		$clean=array();

		// General search action
		foreach($array as $k=>$v){
			if(is_array($v)){
				$clean[$k] = $this->oracle_clean_array($v);
			} else {
				$clean[$k]=$this->oracle_escape($v);
			}
		}

		return $clean;
	} // function oracle_clean_array

	/**
	 * oracle_escape
	 * Thwarts sql injection attacks
	 * @param string $string Dirty value.
	 * @return string Clean values.
	 */
	function oracle_escape($string){
			return str_replace(";"," ",str_replace("\\'","''",addslashes(stripslashes($string))));
	} // function oracle_escape

	// Validating methods
	function is_good_email($email){
		if( !eregi("^[a-z0-9]+([_\\.-][a-z0-9]+)*" ."@([a-z0-9]+([\.-][a-z0-9]{1,})+)*$", $email, $regs))
		{
			return false;
		}
		return true;
	}

	function is_blank($string){
		if(trim($string) == ""){
			return true;
		}
		return false;
	}

	function is_timestamp($date){
		if(empty($date) || !is_numeric($date)){
			return false;
		}
		return true;
		
	}


} // App

?>
